```text
------------------------------------------------------------------
1.
Этот первый путнкт выполняем только один раз, при создании проекта 
```
* Этот вариант создания рабочего проекта
```shell
npx --force create-react-app my-app
```
------------------------------------------------------------------
```

* После создания проекта переходим в корневую папку проекта
```shell
cd my-app
```
* Запускаем проект
```shell
npm start
```
* Перед каждым новым запуском проекта выполняем команду
```shell
cd my-app
```
* Запускаем проект
```shell
npm start
```
---
# О лекции  
В лекции рассказывается о потери контекста при срабатывании события  
Демо в файле [App.js](my-app/src/App.js)  
... добавить общую информацию  
Пути решения   
1. Через bind  
```js
constructor ()
{
//в левой части этой конструкции - свойство экземпляра класса, который уже создан  
//в правой части "this.nextYear" - метод, который есть в классе и при помощи bind мы
// привзываем его к экземпляру класса
    this.nextYear = this.nextYear.bind(this)
}
nextYear(){
    this.setState(state => ({
        years:state.years +1
    }))
}
```  
Петреченко считает это не удобным, потому что каждый метод в классе придется привязывать,
если они искользуются в обработчиках событий  
2. При помощи стрелочных функций  
```js
nextYear = () =>{
    this.setState(state => ({
        years:state.years +1
    }))
}

```
3. Вызов события через анонимную стрелочную функцию
```js   
nextYear (){
    this.setState(state => ({
        years:state.years +1
    }))
}
...
return (
    <div>
        <button onClick={()=>this.nextYear()}>+++</button>
    </div>
)

```
Когда будет клик по элементу button, запустится стрелочная функция ()=> this.nextYear()
внутри которой запустится this.nextYear(), this стрелочная функция берет у своего родителя
попадет ссылка на экземпляр нашего объекта

### Для отмены стандартного поведения браузера используется только e.preventDefault();