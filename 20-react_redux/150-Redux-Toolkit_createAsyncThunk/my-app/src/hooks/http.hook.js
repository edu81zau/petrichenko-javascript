/**
 * `useHttp` - это кастомный хук React для выполнения HTTP-запросов.
 * Он инкапсулирует логику работы с API в одном месте, что делает код более
 * чистым и переиспользуемым в разных компонентах.
 *
 * @returns {{request: Function}} - Хук возвращает объект с единственным
 * свойством `request`, которое является функцией для отправки запросов.
 */
export const useHttp = () => {

    /**
     * `request` - асинхронная функция, которая выполняет запрос к серверу.
     * Она использует `async/await` для упрощения работы с промисами.
     *
     * @param {string} url - URL-адрес, к которому нужно отправить запрос.
     * @param {string} [method='GET'] - HTTP-метод запроса (GET, POST, DELETE и т.д.). По умолчанию 'GET'.
     * @param {object|null} [body=null] - Тело запроса (для POST, PUT и т.п.). По умолчанию `null`.
     * @param {object} [headers={'Content-Type': 'application/json'}] - Заголовки запроса. По умолчанию устанавливает тип контента JSON.
     * @returns {Promise<object>} - Промис, который разрешится данными, полученными с сервера.
     */
    const request = async (url, method = 'GET', body = null, headers = {'Content-Type': 'application/json'}) => {

        try {
            // `fetch` - встроенный в браузер метод для выполнения сетевых запросов.
            // Мы ждем (`await`) ответа от сервера.
            const response = await fetch(url, {method, body, headers});

            // Проверяем, был ли ответ сервера успешным (HTTP-статус в диапазоне 200-299)
            if (!response.ok) {
                // Если ответ не успешный, выбрасываем ошибку с URL и статусом ответа
                throw new Error(`Could not fetch ${url}, status: ${response.status}`);
            }

            // Парсим тело ответа в JSON-формат.
            // Мы ждем (`await`), пока данные будут полностью получены и обработаны
            const data = await response.json();

            // Возвращаем данные, полученные с сервера
            return data;
        } catch (e) {

            // Если в блоке `try` произошла какая-либо ошибка (например, сбой сети или
            // ошибка, которую мы сгенерировали выше), мы "пробрасываем" её дальше.
            // Это позволяет вызывающей стороне (компоненту, thunk'у) обработать ошибку
            // с помощью `.catch()`.
            throw e;
        }
    };

    // Возвращаем функцию `request` в виде объекта.
    // Это позволяет деструктурировать хук в компонентах: `const {request} = useHttp()`
    return {request}
}